[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18458597&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.
Software engineering is the systematic approach to building and maintaining software using engineering principles. It's important to the technology industry because it ensures the software we rely on daily (from apps to websites to critical systems) works reliably and can be updated as needed.

Identify and describe at least three key milestones in the evolution of software engineering.
The creation of high-level programming languages in the 1950s-60s, making code more human-readable and easier for programmers who had to write in machine code prior
The "software crisis" and NATO conferences (1968-69) that established software engineering as a discipline. It meant that there would be a systematic approach to the discipline.
The rise of object-oriented programming in the 1980s-90s, improving code organization and reuse. Programmimg languages like Java made it easier to build and maintain large, complex software systems.

List and briefly explain the phases of the Software Development Life Cycle.
Requirements: this is gathering and determining what the software needs to do
Design: this entails planning the software's structure and appearance
Implementation: this involves writing the actual code
Testing: at this stage, we are ensuring the software works correctly
Deployment: this involves releasing the software to users
Maintenance: the ongoing updates and fixes throughout the software's life

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
Waterfall and Agile represent contrasting development approaches. Waterfall follows a linear, sequential process ideal for projects with stable requirements like banking systems or medical devices. The main advantages are that it's straightforward to understand, has clear milestones, and works well when requirements are unlikely to change. Whereas Agile uses iterative cycles called sprints, embracing change and user feedback, making it better for evolving projects like mobile apps or startups. Agile basically shines in situations where requirements might evolve or aren't fully understood at the beginning. 

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
Software Developers who write code and build features. Their day typically involves writing new code, fixing bugs, refactoring existing code, and collaborating with other developers.
Quality Assurance Engineers who test software and ensure quality. They design test cases, execute tests (both manual and automated), report bugs, and verify fixes.
Project Managers who coordinate timelines, resources, and stakeholder communication. They keep the whole team moving in the right direction.

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
IDEs like Visual Studio and IntelliJ IDEA combine coding, debugging and testing functions. They highlight syntax errors as one types, suggest code completions, and lets one debug by stepping through code line by line. 
Version Control Systems like Git tracks changes and enable team collaboration. Having a complete history of changes serves as a form of documentation and provides a safety net, so if something breaks, one can always go back to a working version.

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
Changing requirements by the client or stakeholders, which can throw off schedules and budgets and sometimes requires reworking code that's already written. To deal with this, it helps to use agile methodologies that expect and accommodate changes.
Technical debt can also happen when one takes shortcuts to meet deadlines making the code harder to work with later. To manage technical debt, teams should schedule regular "refactoring sprints" to clean up code, keep a backlog of technical improvements, and resist the pressure to always prioritize new features over code quality.
Communication issues especially in larger or distributed teams. Misunderstandings about requirements, technical approaches, or priorities can lead to wasted effort and conflicts. Creating a culture of open communication, using collaboration tools effectively, and having regular sync-ups can help keep everyone on the same page. 
Estimating the time and effort for software tasks can be difficult. So, breaking work into smaller, more manageable chunks makes estimation more accurate. 

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
Unit testing that focuses on testing individual components or functions in isolation. Developers write these tests to verify that small pieces of code work correctly on their own. 
Integration testing verifies that different components work together properly. Even if individual parts function correctly, they might fail when combined due to interface mismatches or incorrect assumptions.
System testing evaluates the complete application as a whole to ensure it meets requirements. This involves testing the entire system under conditions that simulate real-world usage. 
Acceptance testing determines if the software meets business requirements and user expectations. These tests focus on real-world scenarios that matter to end users and stakeholders. 

#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.
Prompt engineering is the art of crafting effective inputs for AI models to generate optimal outputs. As AI becomes more integrated into daily life and work, the ability to communicate clearly with these systems grows increasingly important. Well-designed prompts save time and produce consistent, useful results by clearly communicating exactly what information is needed, in what format, and at what level of detail.

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
Vague prompt:  Tell me about climate change
Improved prompt: Explain the basic science behind climate change and its main causes in simple terms
